// vns describes an algorithm based in metaheuristic that starts searching with a single solution.
// They could be see as walks through neihborhoods on search trajectories
// through the search space of the problem at hand.
// The walks are performing by iterative procedures that move from the current
// solution to another one in the search space.

package vns

// Solution describes the representation to VRP problem
type Solution struct {
	// cluster holds the optimization stops, vehicles and distance matrix information
	Cluster *Cluster
	// customers representation as a sequence vector
	Customers []int
	// Routes describes a set of vehicles routes.
	Routes []Route
	// Fitness values describes the solution quality
	FitnessValue float32
}

// Route stores the vehicle routes information
type Route struct {
	Start int
	Size  int
	Cost  float32
}

// HeuristicConstructor describes the behavior to generate a greedy solutions.
// It generates a solution from scratch in a step-by-step manner.
type HeuristicConstructor interface {
	InitSolution() *Solution
}

// NeighborhoodOperator describes the behavior to perform neighborhoods structures.
//
// The Neighborhood N('s) of a candidate solution 's E S is defined by all candidates solutions
// that can be obtained by applying specific modification or movements to 's.
// The Neighborhood structure plays a crucial role in the performance. If the N('s) structure
// is not adequate to the problem, any s-metaheuristic will fail to solve the problem.
//
// A Neighborhood function N is a mapping N: S -> 2's that assigns to each solution 's of S
// a set fo solutions N('s) < S such a ”s E N('s). A solution ”s in the neighborhood of
// 's (”s E N('s)) is called a neighbor of 's. A neighbord is generated by the application of
// a move operator 'm that performs a small perturbation to the solution 's. The structure of
// the N('s) depends on the target optimization problem.
type NeighborhoodOperator interface {
	// BestImprovement chooses the best solution from N('s) where all possible moves are performed
	BestImprovement(s *Solution) *Solution
	// The first improvement strategy tries to avoid the time complexity of exploring
	FirstImprovement(s *Solution) *Solution
}

// Shake transforms one complete candidate solution into another
// complete candidate solution.
type Shaker interface {
	Shake(s *Solution, r *Solution)
}

// Location describes a location point.
type Location struct {
	Name string  `json:"company_name" valid:"required~The name is required"`
	Lat  float64 `json:"lat"`
	Lng  float64 `json:"lng"`
}

// Stop describes a customer's stop location.
type Stop struct {
	StopID              int
	StopName            string
	Demand              float32
	Location            *Location
	StartTimeWindow     float32
	EndTimeWindow       float32
	DurationServiceTime int64 // in minutes
	ArrivalTime         float32
	WaitingTime         float32
	DepartureTime       float32
}

// TravelCost holds the main properties to describes a cost between two points.
type TravelCost struct {
	Distance float32 `json:"distance_in_meters"`
	Time     float32 `json:"travel_time_in_minutes"`
}

// CostMatrix describes a distance matrix between all stops.
type CostMatrix [][]TravelCost

// Vehicle describes a vehicle data.
type Vehicle struct {
	VehicleID        string
	Capacity         float32   `json:"capacity"`
	StartLocation    *Location `json:"start_location"`
	ShiftStart       string    `json:"shift_start"`
	ShiftStartNumber float32   `json:"shift_start_number"`
	ShiftEnd         string    `json:"shift_end"`
	ShiftEndNumber   float32   `json:"shift_end_number"`
}

// Clusters defines an abstraction data structure to store all data
// in order to compute a route optimization.
type Cluster struct {
	Depot      Stop
	Stops      []Stop
	Vehicles   []Vehicle
	CostMatrix CostMatrix
}
